{"version":3,"sources":["../src/useChatData.ts","../src/state.ts","../src/utils/group.ts","../src/useChatInteract.ts","../src/utils/message.ts","../src/context.ts","../src/utils/token.ts","../src/api/hooks/auth.ts","../src/api/hooks/api.ts","../src/api/index.tsx","../src/useChatMessages.ts","../src/useChatSession.ts","../src/useAudio.ts","../src/useConfig.ts","../src/index.ts"],"names":["useRecoilValue","isEqual","DefaultValue","atom","selector","uuidv4","groupByDate","data","groupedData","today","yesterday","sevenDaysAgo","thirtyDaysAgo","item","createdAt","isToday","isYesterday","isLast7Days","isLast30Days","category","threadIdToResumeState","chatProfileState","sessionIdAtom","sessionIdState","get","set","newValue","sessionState","actionState","messagesState","tokenCountState","loadingState","askUserState","callFnState","chatSettingsInputsState","chatSettingsDefaultValueSelector","form","input","chatSettingsValueState","elementState","tasklistState","firstUserInteraction","accessTokenState","userState","configState","threadHistoryState","setSelf","onSet","oldValue","timeGroupedThreads","sideViewState","currentThreadIdState","useChatData","loading","elements","tasklists","actions","session","askUser","callFn","chatSettingsInputs","chatSettingsValue","chatSettingsDefaultValue","connected","disabled","useCallback","useContext","useResetRecoilState","useSetRecoilState","nestMessages","messages","nestedMessages","message","addMessage","isLastMessage","index","i","messageTypes","validRootTypes","isMessageType","isValidRootType","isRoot","parentMessage","findMessageById","shouldWrap","hasMessageById","updateMessageById","lastMessage","collapseTool","addMessageToParent","addIndentMessage","indent","newMessage","currentIndentation","nextMessages","msg","parentId","messageId","foundMessage","updatedMessage","deleteMessageById","updateMessageContentById","updatedContent","isSequence","isInput","createContext","tokenKey","getToken","setToken","token","removeToken","jwt_decode","useEffect","useRecoilState","useMemo","useSWR","fetcher","client","endpoint","useApi","path","swrConfig","ChainlitContext","accessToken","memoizedFetcher","url","swrKey","useAuth","apiClient","isLoading","setAccessToken","setThreadHistory","user","setUser","isReady","logout","saveAndSetToken","exp","User","e","isAuthenticated","ClientError","detail","APIBase","httpEndpoint","type","on401","onError","prefix","method","signal","headers","body","res","error","ChainlitAPI","feedback","feedbackId","pagination","filter","threadId","file","onProgress","sessionId","xhr","promise","resolve","reject","formData","event","percentage","response","id","queryParams","theme","provider","defaultChainlitContext","useChatInteract","resetChatSettings","resetSessionId","resetChatSettingsValue","setFirstUserInteraction","setLoading","setMessages","setElements","setTasklists","setActions","setTokenCount","setIdToResume","setSideView","setCurrentThreadId","clear","sendMessage","fileReferences","oldMessages","sendAudioChunk","isStart","mimeType","elapsedTime","endAudioStream","replyMessage","updateChatSettings","values","stopTask","m","callAction","action","socket","useChatMessages","firstInteraction","debounce","io","useChatSession","setSession","setAskUser","setCallFn","setChatSettingsInputs","chatProfile","setChatProfile","idToResume","_connect","userEnv","protocol","host","pathname","uri","old","s","_","thread","step","spec","callback","name","args","inputs","element","remove","a","count","connect","disconnect","useRef","useState","defaultConfig","useAudio","config","mediaRecorderRef","cancelling","isRecording","setIsRecording","timer","setTimer","isSpeaking","setIsSpeaking","setError","isRecordingFinished","setIsRecordingFinished","cancelRecording","stopRecording","min_decibels","silence_timeout","initial_silence_timeout","chunk_duration","max_duration","stream","spokeAtLeastOnce","isFirstChunk","audioBuffer","startTime","mediaRecorder","track","audioContext","audioStreamSource","analyser","bufferLength","domainData","detectSound","soundDetected","value","err","useConfig","setConfig","language","Socket"],"mappings":"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","sourcesContent":["import { useRecoilValue } from 'recoil';\n\nimport {\n  actionState,\n  askUserState,\n  callFnState,\n  chatSettingsDefaultValueSelector,\n  chatSettingsInputsState,\n  chatSettingsValueState,\n  elementState,\n  loadingState,\n  sessionState,\n  tasklistState\n} from './state';\n\nexport interface IToken {\n  id: number | string;\n  token: string;\n  isSequence: boolean;\n  isInput: boolean;\n}\n\nconst useChatData = () => {\n  const loading = useRecoilValue(loadingState);\n  const elements = useRecoilValue(elementState);\n  const tasklists = useRecoilValue(tasklistState);\n  const actions = useRecoilValue(actionState);\n  const session = useRecoilValue(sessionState);\n  const askUser = useRecoilValue(askUserState);\n  const callFn = useRecoilValue(callFnState);\n  const chatSettingsInputs = useRecoilValue(chatSettingsInputsState);\n  const chatSettingsValue = useRecoilValue(chatSettingsValueState);\n  const chatSettingsDefaultValue = useRecoilValue(\n    chatSettingsDefaultValueSelector\n  );\n\n  const connected = session?.socket.connected && !session?.error;\n  const disabled =\n    !connected ||\n    loading ||\n    askUser?.spec.type === 'file' ||\n    askUser?.spec.type === 'action';\n\n  return {\n    actions,\n    askUser,\n    callFn,\n    chatSettingsDefaultValue,\n    chatSettingsInputs,\n    chatSettingsValue,\n    connected,\n    disabled,\n    elements,\n    error: session?.error,\n    loading,\n    tasklists\n  };\n};\n\nexport { useChatData };\n","import { isEqual } from 'lodash';\nimport { DefaultValue, atom, selector } from 'recoil';\nimport { Socket } from 'socket.io-client';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport {\n  IAction,\n  IAsk,\n  ICallFn,\n  IChainlitConfig,\n  IMessageElement,\n  IStep,\n  ITasklistElement,\n  IUser,\n  ThreadHistory\n} from './types';\nimport { groupByDate } from './utils/group';\n\nexport interface ISession {\n  socket: Socket;\n  error?: boolean;\n}\n\nexport const threadIdToResumeState = atom<string | undefined>({\n  key: 'ThreadIdToResume',\n  default: undefined\n});\n\nexport const chatProfileState = atom<string | undefined>({\n  key: 'ChatProfile',\n  default: undefined\n});\n\nconst sessionIdAtom = atom<string>({\n  key: 'SessionId',\n  default: uuidv4()\n});\n\nexport const sessionIdState = selector({\n  key: 'SessionIdSelector',\n  get: ({ get }) => get(sessionIdAtom),\n  set: ({ set }, newValue) =>\n    set(sessionIdAtom, newValue instanceof DefaultValue ? uuidv4() : newValue)\n});\n\nexport const sessionState = atom<ISession | undefined>({\n  key: 'Session',\n  dangerouslyAllowMutability: true,\n  default: undefined\n});\n\nexport const actionState = atom<IAction[]>({\n  key: 'Actions',\n  default: []\n});\n\nexport const messagesState = atom<IStep[]>({\n  key: 'Messages',\n  dangerouslyAllowMutability: true,\n  default: []\n});\n\nexport const tokenCountState = atom<number>({\n  key: 'TokenCount',\n  default: 0\n});\n\nexport const loadingState = atom<boolean>({\n  key: 'Loading',\n  default: false\n});\n\nexport const askUserState = atom<IAsk | undefined>({\n  key: 'AskUser',\n  default: undefined\n});\n\nexport const callFnState = atom<ICallFn | undefined>({\n  key: 'CallFn',\n  default: undefined\n});\n\nexport const chatSettingsInputsState = atom<any>({\n  key: 'ChatSettings',\n  default: []\n});\n\nexport const chatSettingsDefaultValueSelector = selector({\n  key: 'ChatSettingsValue/Default',\n  get: ({ get }) => {\n    const chatSettings = get(chatSettingsInputsState);\n    return chatSettings.reduce(\n      (form: { [key: string]: any }, input: any) => (\n        (form[input.id] = input.initial), form\n      ),\n      {}\n    );\n  }\n});\n\nexport const chatSettingsValueState = atom({\n  key: 'ChatSettingsValue',\n  default: chatSettingsDefaultValueSelector\n});\n\nexport const elementState = atom<IMessageElement[]>({\n  key: 'DisplayElements',\n  default: []\n});\n\nexport const tasklistState = atom<ITasklistElement[]>({\n  key: 'TasklistElements',\n  default: []\n});\n\nexport const firstUserInteraction = atom<string | undefined>({\n  key: 'FirstUserInteraction',\n  default: undefined\n});\n\nexport const accessTokenState = atom<string | undefined>({\n  key: 'AccessToken',\n  default: undefined\n});\n\nexport const userState = atom<IUser | null>({\n  key: 'User',\n  default: null\n});\n\nexport const configState = atom<IChainlitConfig | undefined>({\n  key: 'ChainlitConfig',\n  default: undefined\n});\n\nexport const threadHistoryState = atom<ThreadHistory | undefined>({\n  key: 'ThreadHistory',\n  default: {\n    threads: undefined,\n    currentThreadId: undefined,\n    timeGroupedThreads: undefined,\n    pageInfo: undefined\n  },\n  effects: [\n    ({ setSelf, onSet }: { setSelf: any; onSet: any }) => {\n      onSet(\n        (\n          newValue: ThreadHistory | undefined,\n          oldValue: ThreadHistory | undefined\n        ) => {\n          let timeGroupedThreads = newValue?.timeGroupedThreads;\n          if (\n            newValue?.threads &&\n            !isEqual(newValue.threads, oldValue?.timeGroupedThreads)\n          ) {\n            timeGroupedThreads = groupByDate(newValue.threads);\n          }\n\n          setSelf({\n            ...newValue,\n            timeGroupedThreads\n          });\n        }\n      );\n    }\n  ]\n});\n\nexport const sideViewState = atom<IMessageElement | undefined>({\n  key: 'SideView',\n  default: undefined\n});\n\nexport const currentThreadIdState = atom<string | undefined>({\n  key: 'CurrentThreadId',\n  default: undefined\n});\n","import { IThread } from 'src/types';\n\nexport const groupByDate = (data: IThread[]) => {\n  const groupedData: { [key: string]: IThread[] } = {};\n\n  const today = new Date();\n  const yesterday = new Date();\n  yesterday.setDate(today.getDate() - 1);\n  const sevenDaysAgo = new Date();\n  sevenDaysAgo.setDate(today.getDate() - 7);\n  const thirtyDaysAgo = new Date();\n  thirtyDaysAgo.setDate(today.getDate() - 30);\n\n  data.forEach((item) => {\n    const createdAt = new Date(item.createdAt);\n    const isToday = createdAt.toDateString() === today.toDateString();\n    const isYesterday = createdAt.toDateString() === yesterday.toDateString();\n    const isLast7Days = createdAt >= sevenDaysAgo;\n    const isLast30Days = createdAt >= thirtyDaysAgo;\n\n    let category: string;\n\n    if (isToday) {\n      category = 'Today';\n    } else if (isYesterday) {\n      category = 'Yesterday';\n    } else if (isLast7Days) {\n      category = 'Previous 7 days';\n    } else if (isLast30Days) {\n      category = 'Previous 30 days';\n    } else {\n      const monthYear = createdAt.toLocaleString('default', {\n        month: 'long',\n        year: 'numeric'\n      });\n\n      category = monthYear.split(' ').slice(0, 1).join(' ');\n    }\n\n    if (!groupedData[category]) {\n      groupedData[category] = [];\n    }\n\n    groupedData[category].push(item);\n  });\n\n  return groupedData;\n};\n","import { useCallback, useContext } from 'react';\nimport { useRecoilValue, useResetRecoilState, useSetRecoilState } from 'recoil';\nimport {\n  accessTokenState,\n  actionState,\n  askUserState,\n  chatSettingsInputsState,\n  chatSettingsValueState,\n  currentThreadIdState,\n  elementState,\n  firstUserInteraction,\n  loadingState,\n  messagesState,\n  sessionIdState,\n  sessionState,\n  sideViewState,\n  tasklistState,\n  threadIdToResumeState,\n  tokenCountState\n} from 'src/state';\nimport { IAction, IFileRef, IStep } from 'src/types';\nimport { addMessage } from 'src/utils/message';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { ChainlitContext } from './context';\n\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nconst useChatInteract = () => {\n  const client = useContext(ChainlitContext);\n  const accessToken = useRecoilValue(accessTokenState);\n  const session = useRecoilValue(sessionState);\n  const askUser = useRecoilValue(askUserState);\n  const sessionId = useRecoilValue(sessionIdState);\n\n  const resetChatSettings = useResetRecoilState(chatSettingsInputsState);\n  const resetSessionId = useResetRecoilState(sessionIdState);\n  const resetChatSettingsValue = useResetRecoilState(chatSettingsValueState);\n\n  const setFirstUserInteraction = useSetRecoilState(firstUserInteraction);\n  const setLoading = useSetRecoilState(loadingState);\n  const setMessages = useSetRecoilState(messagesState);\n  const setElements = useSetRecoilState(elementState);\n  const setTasklists = useSetRecoilState(tasklistState);\n  const setActions = useSetRecoilState(actionState);\n  const setTokenCount = useSetRecoilState(tokenCountState);\n  const setIdToResume = useSetRecoilState(threadIdToResumeState);\n  const setSideView = useSetRecoilState(sideViewState);\n  const setCurrentThreadId = useSetRecoilState(currentThreadIdState);\n\n  const clear = useCallback(() => {\n    session?.socket.emit('clear_session');\n    session?.socket.disconnect();\n    setIdToResume(undefined);\n    resetSessionId();\n    setFirstUserInteraction(undefined);\n    setMessages([]);\n    setElements([]);\n    setTasklists([]);\n    setActions([]);\n    setTokenCount(0);\n    resetChatSettings();\n    resetChatSettingsValue();\n    setSideView(undefined);\n    setCurrentThreadId(undefined);\n  }, [session]);\n\n  const sendMessage = useCallback(\n    (\n      message: PartialBy<IStep, 'createdAt' | 'id'>,\n      fileReferences: IFileRef[] = []\n    ) => {\n      if (!message.id) {\n        message.id = uuidv4();\n      }\n      if (!message.createdAt) {\n        message.createdAt = new Date().toISOString();\n      }\n      setMessages((oldMessages) => addMessage(oldMessages, message as IStep));\n\n      session?.socket.emit('client_message', { message, fileReferences });\n    },\n    [session?.socket]\n  );\n\n  const sendAudioChunk = useCallback(\n    (isStart: boolean, mimeType: string, elapsedTime: number, data: Blob) => {\n      session?.socket.emit('audio_chunk', {\n        isStart,\n        mimeType,\n        elapsedTime,\n        data\n      });\n    },\n    [session?.socket]\n  );\n\n  const endAudioStream = useCallback(\n    (fileReferences?: IFileRef[]) => {\n      session?.socket.emit('audio_end', { fileReferences });\n    },\n    [session?.socket]\n  );\n\n  const replyMessage = useCallback(\n    (message: IStep) => {\n      if (askUser) {\n        setMessages((oldMessages) => addMessage(oldMessages, message));\n        askUser.callback(message);\n      }\n    },\n    [askUser]\n  );\n\n  const updateChatSettings = useCallback(\n    (values: object) => {\n      session?.socket.emit('chat_settings_change', values);\n    },\n    [session?.socket]\n  );\n\n  const stopTask = useCallback(() => {\n    setMessages((oldMessages) =>\n      oldMessages.map((m) => {\n        m.streaming = false;\n        return m;\n      })\n    );\n\n    setLoading(false);\n\n    session?.socket.emit('stop');\n  }, [session?.socket]);\n\n  const callAction = useCallback(\n    (action: IAction) => {\n      const socket = session?.socket;\n      if (!socket) return;\n\n      const promise = new Promise<{\n        id: string;\n        status: boolean;\n        response?: string;\n      }>((resolve, reject) => {\n        socket.once('action_response', (response) => {\n          if (response.status) {\n            resolve(response);\n          } else {\n            reject(response);\n          }\n        });\n      });\n\n      socket.emit('action_call', action);\n\n      return promise;\n    },\n    [session?.socket]\n  );\n\n  const uploadFile = useCallback(\n    (file: File, onProgress: (progress: number) => void) => {\n      return client.uploadFile(file, onProgress, sessionId, accessToken);\n    },\n    [sessionId, accessToken]\n  );\n\n  return {\n    uploadFile,\n    callAction,\n    clear,\n    replyMessage,\n    sendMessage,\n    sendAudioChunk,\n    endAudioStream,\n    stopTask,\n    setIdToResume,\n    updateChatSettings\n  };\n};\n\nexport { useChatInteract };\n","import { isEqual } from 'lodash';\n\nimport { IStep } from '..';\n\nconst nestMessages = (messages: IStep[]): IStep[] => {\n  let nestedMessages: IStep[] = [];\n\n  for (const message of messages) {\n    nestedMessages = addMessage(nestedMessages, message);\n  }\n\n  return nestedMessages;\n};\n\nconst isLastMessage = (messages: IStep[], index: number) => {\n  if (messages.length - 1 === index) {\n    return true;\n  }\n\n  for (let i = index + 1; i < messages.length; i++) {\n    if (messages[i].streaming) {\n      continue;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// Nested messages utils\n\nconst addMessage = (messages: IStep[], message: IStep): IStep[] => {\n  const messageTypes = ['assistant_message', 'user_message'];\n  const validRootTypes = [...messageTypes, 'tool'];\n  const isMessageType = messageTypes.includes(message.type);\n  const isValidRootType = validRootTypes.includes(message.type);\n  const isRoot = !message.parentId;\n\n  if (isRoot && !isValidRootType) {\n    return messages;\n  }\n\n  const parentMessage = !isRoot\n    ? findMessageById(messages, message.parentId!)\n    : undefined;\n\n  const shouldWrap =\n    (isRoot || parentMessage?.type !== 'assistant_message') &&\n    message.type === 'tool';\n\n  if (hasMessageById(messages, message.id)) {\n    return updateMessageById(messages, message.id, message);\n  } else if (shouldWrap) {\n    const lastMessage =\n      messages.length > 0 ? messages[messages.length - 1] : undefined;\n    const collapseTool =\n      lastMessage?.type === 'assistant_message' &&\n      lastMessage?.id.startsWith('wrap_');\n    if (lastMessage && collapseTool) {\n      return [\n        ...messages.slice(0, messages.length - 1),\n        {\n          ...lastMessage,\n          steps: [...(lastMessage.steps || []), message]\n        }\n      ];\n    }\n    return [\n      ...messages,\n      {\n        ...message,\n        name: '',\n        input: '',\n        output: '',\n        id: 'wrap_' + message.id,\n        type: 'assistant_message',\n        steps: [message]\n      }\n    ];\n  } else if (!isMessageType && 'parentId' in message && message.parentId) {\n    return addMessageToParent(messages, message.parentId, message);\n  } else if ('indent' in message && message.indent && message.indent > 0) {\n    return addIndentMessage(messages, message.indent, message);\n  } else {\n    return [...messages, message];\n  }\n};\n\nconst addIndentMessage = (\n  messages: IStep[],\n  indent: number,\n  newMessage: IStep,\n  currentIndentation: number = 0\n): IStep[] => {\n  const nextMessages = [...messages];\n\n  if (nextMessages.length === 0) {\n    return [...nextMessages, newMessage];\n  } else {\n    const index = nextMessages.length - 1;\n    const msg = nextMessages[index];\n    msg.steps = msg.steps || [];\n\n    if (currentIndentation + 1 === indent) {\n      msg.steps = [...msg.steps, newMessage];\n      nextMessages[index] = { ...msg };\n\n      return nextMessages;\n    } else {\n      msg.steps = addIndentMessage(\n        msg.steps,\n        indent,\n        newMessage,\n        currentIndentation + 1\n      );\n\n      nextMessages[index] = { ...msg };\n      return nextMessages;\n    }\n  }\n};\n\nconst addMessageToParent = (\n  messages: IStep[],\n  parentId: string,\n  newMessage: IStep\n): IStep[] => {\n  const nextMessages = [...messages];\n\n  for (let index = 0; index < nextMessages.length; index++) {\n    const msg = nextMessages[index];\n\n    if (isEqual(msg.id, parentId)) {\n      msg.steps = msg.steps ? [...msg.steps, newMessage] : [newMessage];\n      nextMessages[index] = { ...msg };\n    } else if (hasMessageById(nextMessages, parentId) && msg.steps) {\n      msg.steps = addMessageToParent(msg.steps, parentId, newMessage);\n      nextMessages[index] = { ...msg };\n    }\n  }\n\n  return nextMessages;\n};\n\nconst findMessageById = (\n  messages: IStep[],\n  messageId: string\n): IStep | undefined => {\n  for (const message of messages) {\n    if (isEqual(message.id, messageId)) {\n      return message;\n    } else if (message.steps && message.steps.length > 0) {\n      const foundMessage = findMessageById(message.steps, messageId);\n      if (foundMessage) {\n        return foundMessage;\n      }\n    }\n  }\n  return undefined;\n};\n\nconst hasMessageById = (messages: IStep[], messageId: string): boolean => {\n  return findMessageById(messages, messageId) !== undefined;\n};\n\nconst updateMessageById = (\n  messages: IStep[],\n  messageId: string,\n  updatedMessage: IStep\n): IStep[] => {\n  const nextMessages = [...messages];\n\n  for (let index = 0; index < nextMessages.length; index++) {\n    const msg = nextMessages[index];\n\n    if (isEqual(msg.id, messageId)) {\n      nextMessages[index] = { steps: msg.steps, ...updatedMessage };\n    } else if (hasMessageById(nextMessages, messageId) && msg.steps) {\n      msg.steps = updateMessageById(msg.steps, messageId, updatedMessage);\n      nextMessages[index] = { ...msg };\n    }\n  }\n\n  return nextMessages;\n};\n\nconst deleteMessageById = (messages: IStep[], messageId: string) => {\n  let nextMessages = [...messages];\n\n  for (let index = 0; index < nextMessages.length; index++) {\n    const msg = nextMessages[index];\n\n    if (msg.id === messageId) {\n      nextMessages = [\n        ...nextMessages.slice(0, index),\n        ...nextMessages.slice(index + 1)\n      ];\n    } else if (hasMessageById(nextMessages, messageId) && msg.steps) {\n      msg.steps = deleteMessageById(msg.steps, messageId);\n      nextMessages[index] = { ...msg };\n    }\n  }\n\n  return nextMessages;\n};\n\nconst updateMessageContentById = (\n  messages: IStep[],\n  messageId: number | string,\n  updatedContent: string,\n  isSequence: boolean,\n  isInput: boolean\n): IStep[] => {\n  const nextMessages = [...messages];\n  for (let index = 0; index < nextMessages.length; index++) {\n    const msg = nextMessages[index];\n\n    if (isEqual(msg.id, messageId)) {\n      if ('content' in msg && msg.content !== undefined) {\n        if (isSequence) {\n          msg.content = updatedContent;\n        } else {\n          msg.content += updatedContent;\n        }\n      } else if (isInput) {\n        if ('input' in msg && msg.input !== undefined) {\n          if (isSequence) {\n            msg.input = updatedContent;\n          } else {\n            msg.input += updatedContent;\n          }\n        }\n      } else {\n        if ('output' in msg && msg.output !== undefined) {\n          if (isSequence) {\n            msg.output = updatedContent;\n          } else {\n            msg.output += updatedContent;\n          }\n        }\n      }\n\n      nextMessages[index] = { ...msg };\n    } else if (msg.steps) {\n      msg.steps = updateMessageContentById(\n        msg.steps,\n        messageId,\n        updatedContent,\n        isSequence,\n        isInput\n      );\n      nextMessages[index] = { ...msg };\n    }\n  }\n\n  return nextMessages;\n};\n\nexport {\n  addMessageToParent,\n  addMessage,\n  deleteMessageById,\n  hasMessageById,\n  isLastMessage,\n  nestMessages,\n  updateMessageById,\n  updateMessageContentById\n};\n","import { createContext } from 'react';\n\nimport { ChainlitAPI } from './api';\n\nconst defaultChainlitContext = undefined;\n\nconst ChainlitContext = createContext<ChainlitAPI>(\n  new ChainlitAPI('http://localhost:8000', 'webapp')\n);\n\nexport { ChainlitContext, defaultChainlitContext };\n","const tokenKey = 'token';\n\nexport function getToken() {\n  try {\n    return localStorage.getItem(tokenKey);\n  } catch (e) {\n    return;\n  }\n}\n\nexport function setToken(token: string) {\n  try {\n    return localStorage.setItem(tokenKey, token);\n  } catch (e) {\n    return;\n  }\n}\n\nexport function removeToken() {\n  try {\n    return localStorage.removeItem(tokenKey);\n  } catch (e) {\n    return;\n  }\n}\n","import jwt_decode from 'jwt-decode';\nimport { useContext, useEffect } from 'react';\nimport { useRecoilState, useSetRecoilState } from 'recoil';\nimport { ChainlitContext } from 'src/context';\nimport { accessTokenState, threadHistoryState, userState } from 'src/state';\nimport { IUser } from 'src/types';\nimport { getToken, removeToken, setToken } from 'src/utils/token';\n\nimport { useApi } from './api';\n\nexport const useAuth = () => {\n  const apiClient = useContext(ChainlitContext);\n  const { data, isLoading } = useApi<{\n    requireLogin: boolean;\n    passwordAuth: boolean;\n    headerAuth: boolean;\n    oauthProviders: string[];\n  }>('/auth/config');\n  const [accessToken, setAccessToken] = useRecoilState(accessTokenState);\n  const setThreadHistory = useSetRecoilState(threadHistoryState);\n  const [user, setUser] = useRecoilState(userState);\n\n  const isReady = !!(!isLoading && data);\n\n  const logout = async () => {\n    await apiClient.logout();\n    setUser(null);\n    removeToken();\n    setAccessToken('');\n    setThreadHistory(undefined);\n  };\n\n  const saveAndSetToken = (token: string | null | undefined) => {\n    if (!token) {\n      logout();\n      return;\n    }\n    try {\n      const { exp, ...User } = jwt_decode(token) as any;\n      setToken(token);\n      setAccessToken(`Bearer ${token}`);\n      setUser(User as IUser);\n    } catch (e) {\n      console.error(\n        'Invalid token, clearing token from local storage',\n        'error:',\n        e\n      );\n      logout();\n    }\n  };\n\n  useEffect(() => {\n    if (!user && getToken()) {\n      // Initialize the token from local storage\n      saveAndSetToken(getToken());\n      return;\n    }\n  }, []);\n\n  const isAuthenticated = !!accessToken;\n\n  if (data && !data.requireLogin) {\n    return {\n      data,\n      user: null,\n      isReady,\n      isAuthenticated: true,\n      accessToken: '',\n      logout: () => {},\n      setAccessToken: () => {}\n    };\n  }\n\n  return {\n    data,\n    user: user,\n    isAuthenticated,\n    isReady,\n    accessToken: accessToken,\n    logout: logout,\n    setAccessToken: saveAndSetToken\n  };\n};\n","import { useContext, useMemo } from 'react';\nimport { useRecoilValue } from 'recoil';\nimport { ChainlitAPI } from 'src/api';\nimport { ChainlitContext } from 'src/context';\nimport { accessTokenState } from 'src/state';\nimport useSWR, { SWRConfiguration } from 'swr';\n\nconst fetcher = async (\n  client: ChainlitAPI,\n  endpoint: string,\n  token?: string\n) => {\n  const res = await client.get(endpoint, token);\n  return res?.json();\n};\n\nfunction useApi<T>(\n  path?: string | null,\n  { token, ...swrConfig }: SWRConfiguration & { token?: string } = {}\n) {\n  const client = useContext(ChainlitContext);\n  let accessToken = useRecoilValue(accessTokenState);\n  accessToken = token || accessToken;\n\n  // Memoize the fetcher function to avoid recreating it on every render\n  const memoizedFetcher = useMemo(\n    () =>\n      ([url, token]: [url: string, token: string]) =>\n        fetcher(client, url, token),\n    [client]\n  );\n\n  // Use a stable key for useSWR\n  const swrKey = useMemo(() => {\n    return path ? [path, accessToken] : null;\n  }, [path, accessToken]);\n\n  return useSWR<T, Error>(swrKey, memoizedFetcher, swrConfig);\n}\n\nexport { useApi, fetcher };\n","import { IThread } from 'src/types';\nimport { removeToken } from 'src/utils/token';\n\nimport { IFeedback } from 'src/types/feedback';\n\nexport * from './hooks/auth';\nexport * from './hooks/api';\n\nexport interface IThreadFilters {\n  search?: string;\n  feedback?: number;\n}\n\nexport interface IPageInfo {\n  hasNextPage: boolean;\n  endCursor?: string;\n}\n\nexport interface IPagination {\n  first: number;\n  cursor?: string | number;\n}\n\nexport class ClientError extends Error {\n  detail?: string;\n\n  constructor(message: string, detail?: string) {\n    super(message);\n    this.detail = detail;\n  }\n\n  toString() {\n    if (this.detail) {\n      return `${this.message}: ${this.detail}`;\n    } else {\n      return this.message;\n    }\n  }\n}\n\ntype Payload = FormData | any;\n\nexport class APIBase {\n  constructor(\n    public httpEndpoint: string,\n    public type: 'webapp' | 'copilot' | 'teams' | 'slack' | 'discord',\n    public on401?: () => void,\n    public onError?: (error: ClientError) => void\n  ) {}\n\n  buildEndpoint(path: string) {\n    if (this.httpEndpoint.endsWith('/')) {\n      // remove trailing slash on httpEndpoint\n      return `${this.httpEndpoint.slice(0, -1)}${path}`;\n    } else {\n      return `${this.httpEndpoint}${path}`;\n    }\n  }\n\n  checkToken(token: string) {\n    const prefix = 'Bearer ';\n    if (token.startsWith(prefix)) {\n      return token;\n    } else {\n      return prefix + token;\n    }\n  }\n\n  async fetch(\n    method: string,\n    path: string,\n    token?: string,\n    data?: Payload,\n    signal?: AbortSignal\n  ): Promise<Response> {\n    try {\n      const headers: { Authorization?: string; 'Content-Type'?: string } = {};\n      if (token) headers['Authorization'] = this.checkToken(token); // Assuming token is a bearer token\n\n      let body;\n\n      if (data instanceof FormData) {\n        body = data;\n      } else {\n        headers['Content-Type'] = 'application/json';\n        body = data ? JSON.stringify(data) : null;\n      }\n\n      const res = await fetch(this.buildEndpoint(path), {\n        method,\n        headers,\n        signal,\n        body\n      });\n\n      if (!res.ok) {\n        const body = await res.json();\n        if (res.status === 401 && this.on401) {\n          removeToken();\n          this.on401();\n        }\n        throw new ClientError(res.statusText, body.detail);\n      }\n\n      return res;\n    } catch (error: any) {\n      if (error instanceof ClientError && this.onError) {\n        this.onError(error);\n      }\n      console.error(error);\n      throw error;\n    }\n  }\n\n  async get(endpoint: string, token?: string) {\n    return await this.fetch('GET', endpoint, token);\n  }\n\n  async post(\n    endpoint: string,\n    data: Payload,\n    token?: string,\n    signal?: AbortSignal\n  ) {\n    return await this.fetch('POST', endpoint, token, data, signal);\n  }\n\n  async put(endpoint: string, data: Payload, token?: string) {\n    return await this.fetch('PUT', endpoint, token, data);\n  }\n\n  async patch(endpoint: string, data: Payload, token?: string) {\n    return await this.fetch('PATCH', endpoint, token, data);\n  }\n\n  async delete(endpoint: string, data: Payload, token?: string) {\n    return await this.fetch('DELETE', endpoint, token, data);\n  }\n}\n\nexport class ChainlitAPI extends APIBase {\n  async headerAuth() {\n    const res = await this.post(`/auth/header`, {});\n    return res.json();\n  }\n\n  async passwordAuth(data: FormData) {\n    const res = await this.post(`/login`, data);\n    return res.json();\n  }\n\n  async logout() {\n    const res = await this.post(`/logout`, {});\n    return res.json();\n  }\n\n  async setFeedback(\n    feedback: IFeedback,\n    accessToken?: string\n  ): Promise<{ success: boolean; feedbackId: string }> {\n    const res = await this.put(`/feedback`, { feedback }, accessToken);\n    return res.json();\n  }\n\n  async deleteFeedback(\n    feedbackId: string,\n    accessToken?: string\n  ): Promise<{ success: boolean }> {\n    const res = await this.delete(`/feedback`, { feedbackId }, accessToken);\n    return res.json();\n  }\n\n  async listThreads(\n    pagination: IPagination,\n    filter: IThreadFilters,\n    accessToken?: string\n  ): Promise<{\n    pageInfo: IPageInfo;\n    data: IThread[];\n  }> {\n    const res = await this.post(\n      `/project/threads`,\n      { pagination, filter },\n      accessToken\n    );\n\n    return res.json();\n  }\n\n  async deleteThread(threadId: string, accessToken?: string) {\n    const res = await this.delete(`/project/thread`, { threadId }, accessToken);\n\n    return res.json();\n  }\n\n  uploadFile(\n    file: File,\n    onProgress: (progress: number) => void,\n    sessionId: string,\n    token?: string\n  ) {\n    const xhr = new XMLHttpRequest();\n\n    const promise = new Promise<{ id: string }>((resolve, reject) => {\n      const formData = new FormData();\n      formData.append('file', file);\n\n      xhr.open(\n        'POST',\n        this.buildEndpoint(`/project/file?session_id=${sessionId}`),\n        true\n      );\n\n      if (token) {\n        xhr.setRequestHeader('Authorization', this.checkToken(token));\n      }\n\n      // Track the progress of the upload\n      xhr.upload.onprogress = function (event) {\n        if (event.lengthComputable) {\n          const percentage = (event.loaded / event.total) * 100;\n          onProgress(percentage);\n        }\n      };\n\n      xhr.onload = function () {\n        if (xhr.status === 200) {\n          const response = JSON.parse(xhr.responseText);\n          resolve(response);\n        } else {\n          reject('Upload failed');\n        }\n      };\n\n      xhr.onerror = function () {\n        reject('Upload error');\n      };\n\n      xhr.send(formData);\n    });\n\n    return { xhr, promise };\n  }\n\n  getElementUrl(id: string, sessionId: string) {\n    const queryParams = `?session_id=${sessionId}`;\n    return this.buildEndpoint(`/project/file/${id}${queryParams}`);\n  }\n\n  getLogoEndpoint(theme: string) {\n    return this.buildEndpoint(`/logo?theme=${theme}`);\n  }\n\n  getOAuthEndpoint(provider: string) {\n    return this.buildEndpoint(`/auth/oauth/${provider}`);\n  }\n}\n","import { useRecoilValue } from 'recoil';\n\nimport {\n  currentThreadIdState,\n  firstUserInteraction,\n  messagesState\n} from './state';\n\nconst useChatMessages = () => {\n  const messages = useRecoilValue(messagesState);\n  const firstInteraction = useRecoilValue(firstUserInteraction);\n  const threadId = useRecoilValue(currentThreadIdState);\n\n  return {\n    threadId,\n    messages,\n    firstInteraction\n  };\n};\n\nexport { useChatMessages };\n","import { debounce } from 'lodash';\nimport { useCallback, useContext } from 'react';\nimport {\n  useRecoilState,\n  useRecoilValue,\n  useResetRecoilState,\n  useSetRecoilState\n} from 'recoil';\nimport io from 'socket.io-client';\nimport {\n  actionState,\n  askUserState,\n  callFnState,\n  chatProfileState,\n  chatSettingsInputsState,\n  chatSettingsValueState,\n  currentThreadIdState,\n  elementState,\n  firstUserInteraction,\n  loadingState,\n  messagesState,\n  sessionIdState,\n  sessionState,\n  tasklistState,\n  threadIdToResumeState,\n  tokenCountState\n} from 'src/state';\nimport {\n  IAction,\n  IElement,\n  IMessageElement,\n  IStep,\n  ITasklistElement,\n  IThread\n} from 'src/types';\nimport {\n  addMessage,\n  deleteMessageById,\n  updateMessageById,\n  updateMessageContentById\n} from 'src/utils/message';\n\nimport { ChainlitContext } from './context';\nimport type { IToken } from './useChatData';\n\nconst useChatSession = () => {\n  const client = useContext(ChainlitContext);\n  const sessionId = useRecoilValue(sessionIdState);\n\n  const [session, setSession] = useRecoilState(sessionState);\n\n  const resetChatSettingsValue = useResetRecoilState(chatSettingsValueState);\n  const setFirstUserInteraction = useSetRecoilState(firstUserInteraction);\n  const setLoading = useSetRecoilState(loadingState);\n  const setMessages = useSetRecoilState(messagesState);\n  const setAskUser = useSetRecoilState(askUserState);\n  const setCallFn = useSetRecoilState(callFnState);\n\n  const setElements = useSetRecoilState(elementState);\n  const setTasklists = useSetRecoilState(tasklistState);\n  const setActions = useSetRecoilState(actionState);\n  const setChatSettingsInputs = useSetRecoilState(chatSettingsInputsState);\n  const setTokenCount = useSetRecoilState(tokenCountState);\n  const [chatProfile, setChatProfile] = useRecoilState(chatProfileState);\n  const idToResume = useRecoilValue(threadIdToResumeState);\n  const setCurrentThreadId = useSetRecoilState(currentThreadIdState);\n  const _connect = useCallback(\n    ({\n      userEnv,\n      accessToken\n    }: {\n      userEnv: Record<string, string>;\n      accessToken?: string;\n    }) => {\n      const { protocol, host, pathname } = new URL(client.httpEndpoint);\n      const uri = `${protocol}//${host}`;\n      const path =\n        pathname && pathname !== '/'\n          ? `${pathname}/ws/socket.io`\n          : '/ws/socket.io';\n\n      const socket = io(uri, {\n        path,\n        extraHeaders: {\n          Authorization: accessToken || '',\n          'X-Chainlit-Client-Type': client.type,\n          'X-Chainlit-Session-Id': sessionId,\n          'X-Chainlit-Thread-Id': idToResume || '',\n          'user-env': JSON.stringify(userEnv),\n          'X-Chainlit-Chat-Profile': chatProfile\n            ? encodeURIComponent(chatProfile)\n            : ''\n        }\n      });\n      setSession((old) => {\n        old?.socket?.removeAllListeners();\n        old?.socket?.close();\n        return {\n          socket\n        };\n      });\n\n      socket.on('connect', () => {\n        socket.emit('connection_successful');\n        setSession((s) => ({ ...s!, error: false }));\n      });\n\n      socket.on('connect_error', (_) => {\n        setSession((s) => ({ ...s!, error: true }));\n      });\n\n      socket.on('task_start', () => {\n        setLoading(true);\n      });\n\n      socket.on('task_end', () => {\n        setLoading(false);\n      });\n\n      socket.on('reload', () => {\n        socket.emit('clear_session');\n        window.location.reload();\n      });\n\n      socket.on('resume_thread', (thread: IThread) => {\n        let messages: IStep[] = [];\n        for (const step of thread.steps) {\n          messages = addMessage(messages, step);\n        }\n        if (thread.metadata?.chat_profile) {\n          setChatProfile(thread.metadata?.chat_profile);\n        }\n        setMessages(messages);\n        const elements = thread.elements || [];\n        setTasklists(\n          (elements as ITasklistElement[]).filter((e) => e.type === 'tasklist')\n        );\n        setElements(\n          (elements as IMessageElement[]).filter(\n            (e) => ['avatar', 'tasklist'].indexOf(e.type) === -1\n          )\n        );\n      });\n\n      socket.on('new_message', (message: IStep) => {\n        setMessages((oldMessages) => addMessage(oldMessages, message));\n      });\n\n      socket.on(\n        'first_interaction',\n        (event: { interaction: string; thread_id: string }) => {\n          setFirstUserInteraction(event.interaction);\n          setCurrentThreadId(event.thread_id);\n        }\n      );\n\n      socket.on('update_message', (message: IStep) => {\n        setMessages((oldMessages) =>\n          updateMessageById(oldMessages, message.id, message)\n        );\n      });\n\n      socket.on('delete_message', (message: IStep) => {\n        setMessages((oldMessages) =>\n          deleteMessageById(oldMessages, message.id)\n        );\n      });\n\n      socket.on('stream_start', (message: IStep) => {\n        setMessages((oldMessages) => addMessage(oldMessages, message));\n      });\n\n      socket.on(\n        'stream_token',\n        ({ id, token, isSequence, isInput }: IToken) => {\n          setMessages((oldMessages) =>\n            updateMessageContentById(\n              oldMessages,\n              id,\n              token,\n              isSequence,\n              isInput\n            )\n          );\n        }\n      );\n\n      socket.on('ask', ({ msg, spec }, callback) => {\n        setAskUser({ spec, callback });\n        setMessages((oldMessages) => addMessage(oldMessages, msg));\n\n        setLoading(false);\n      });\n\n      socket.on('ask_timeout', () => {\n        setAskUser(undefined);\n        setLoading(false);\n      });\n\n      socket.on('clear_ask', () => {\n        setAskUser(undefined);\n      });\n\n      socket.on('call_fn', ({ name, args }, callback) => {\n        setCallFn({ name, args, callback });\n      });\n\n      socket.on('clear_call_fn', () => {\n        setCallFn(undefined);\n      });\n\n      socket.on('call_fn_timeout', () => {\n        setCallFn(undefined);\n      });\n\n      socket.on('chat_settings', (inputs: any) => {\n        setChatSettingsInputs(inputs);\n        resetChatSettingsValue();\n      });\n\n      socket.on('element', (element: IElement) => {\n        if (!element.url && element.chainlitKey) {\n          element.url = client.getElementUrl(element.chainlitKey, sessionId);\n        }\n\n        if (element.type === 'tasklist') {\n          setTasklists((old) => {\n            const index = old.findIndex((e) => e.id === element.id);\n            if (index === -1) {\n              return [...old, element];\n            } else {\n              return [...old.slice(0, index), element, ...old.slice(index + 1)];\n            }\n          });\n        } else {\n          setElements((old) => {\n            const index = old.findIndex((e) => e.id === element.id);\n            if (index === -1) {\n              return [...old, element];\n            } else {\n              return [...old.slice(0, index), element, ...old.slice(index + 1)];\n            }\n          });\n        }\n      });\n\n      socket.on('remove_element', (remove: { id: string }) => {\n        setElements((old) => {\n          return old.filter((e) => e.id !== remove.id);\n        });\n        setTasklists((old) => {\n          return old.filter((e) => e.id !== remove.id);\n        });\n      });\n\n      socket.on('action', (action: IAction) => {\n        setActions((old) => [...old, action]);\n      });\n\n      socket.on('remove_action', (action: IAction) => {\n        setActions((old) => {\n          const index = old.findIndex((a) => a.id === action.id);\n          if (index === -1) return old;\n          return [...old.slice(0, index), ...old.slice(index + 1)];\n        });\n      });\n\n      socket.on('token_usage', (count: number) => {\n        setTokenCount((old) => old + count);\n      });\n    },\n    [setSession, sessionId, chatProfile]\n  );\n\n  const connect = useCallback(debounce(_connect, 200), [_connect]);\n\n  const disconnect = useCallback(() => {\n    if (session?.socket) {\n      session.socket.removeAllListeners();\n      session.socket.close();\n    }\n  }, [session]);\n\n  return {\n    connect,\n    disconnect,\n    session,\n    sessionId,\n    chatProfile,\n    idToResume,\n    setChatProfile\n  };\n};\n\nexport { useChatSession };\n","import { useCallback, useRef, useState } from 'react';\n\nimport { IAudioConfig, IFileRef } from './types';\nimport { useChatInteract } from './useChatInteract';\n\nconst defaultConfig: IAudioConfig = {\n  enabled: true,\n  min_decibels: -45,\n  initial_silence_timeout: 3000,\n  silence_timeout: 1500,\n  max_duration: 15000,\n  chunk_duration: 1000\n};\n\nconst useAudio = (config = defaultConfig) => {\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const cancelling = useRef(false);\n  const { sendAudioChunk, endAudioStream } = useChatInteract();\n  const [isRecording, setIsRecording] = useState(false);\n  const [timer, setTimer] = useState<NodeJS.Timeout | undefined>(undefined);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n  const [error, setError] = useState<string | undefined>(undefined);\n  const [isRecordingFinished, setIsRecordingFinished] = useState(false);\n\n  const cancelRecording = useCallback(() => {\n    if (!isRecording || !mediaRecorderRef.current) {\n      return;\n    }\n    cancelling.current = true;\n    mediaRecorderRef.current.stop();\n  }, [isRecording]);\n\n  const stopRecording = useCallback(() => {\n    if (!isRecording || !mediaRecorderRef.current) {\n      return;\n    }\n    mediaRecorderRef.current.stop();\n  }, [isRecording]);\n\n  const startRecording = useCallback(\n    (fileReferences?: IFileRef[]) => {\n      if (isRecording || !config) {\n        return;\n      }\n      setIsRecordingFinished(false);\n      setError(undefined);\n      clearTimeout(timer);\n      cancelling.current = false;\n\n      const {\n        min_decibels,\n        silence_timeout,\n        initial_silence_timeout,\n        chunk_duration,\n        max_duration\n      } = config;\n\n      navigator.mediaDevices\n        .getUserMedia({ audio: true })\n        .then((stream) => {\n          let spokeAtLeastOnce = false;\n          let isSpeaking = false;\n          let isFirstChunk = true;\n          let audioBuffer: Blob | null = null;\n          let startTime = Date.now();\n\n          const mediaRecorder = new MediaRecorder(stream);\n          mediaRecorderRef.current = mediaRecorder;\n          mediaRecorder.addEventListener('start', () => {\n            setIsRecording(true);\n            startTime = Date.now();\n          });\n\n          mediaRecorder.addEventListener('dataavailable', async (event) => {\n            if (!spokeAtLeastOnce) {\n              if (!audioBuffer) {\n                audioBuffer = new Blob([event.data], { type: event.data.type });\n              } else {\n                audioBuffer = new Blob([audioBuffer, event.data], {\n                  type: event.data.type\n                });\n              }\n            }\n            if (mediaRecorder.state === 'inactive') {\n              return;\n            }\n            const elapsedTime = Date.now() - startTime;\n            if (elapsedTime >= max_duration) {\n              mediaRecorder.stop();\n              stream.getTracks().forEach((track) => track.stop());\n              return;\n            }\n\n            setIsSpeaking(isSpeaking);\n            const [mimeType, _] = mediaRecorder.mimeType.split(';');\n\n            if (audioBuffer) {\n              // If there is buffered data and the user has spoken, send the buffered data first\n              await sendAudioChunk(\n                isFirstChunk,\n                mimeType,\n                elapsedTime,\n                new Blob([audioBuffer, event.data])\n              );\n              audioBuffer = null; // Clear the buffer\n            } else {\n              await sendAudioChunk(\n                isFirstChunk,\n                mimeType,\n                elapsedTime,\n                event.data\n              );\n            }\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n            }\n          });\n\n          mediaRecorder.addEventListener('stop', async () => {\n            setIsRecording(false);\n            setIsSpeaking(false);\n\n            if (spokeAtLeastOnce && !cancelling.current) {\n              setIsRecordingFinished(true);\n              await endAudioStream(fileReferences);\n            }\n          });\n\n          const audioContext = new AudioContext();\n          const audioStreamSource =\n            audioContext.createMediaStreamSource(stream);\n          const analyser = audioContext.createAnalyser();\n          analyser.minDecibels = min_decibels;\n          audioStreamSource.connect(analyser);\n\n          const bufferLength = analyser.frequencyBinCount;\n\n          const domainData = new Uint8Array(bufferLength);\n\n          mediaRecorder.start(chunk_duration);\n\n          const detectSound = () => {\n            if (mediaRecorder.state === 'inactive') {\n              return;\n            }\n            analyser.getByteFrequencyData(domainData);\n            const soundDetected = domainData.some((value) => value > 0);\n\n            if (!isSpeaking) {\n              isSpeaking = soundDetected;\n            }\n            if (!spokeAtLeastOnce && soundDetected) {\n              setIsSpeaking(isSpeaking);\n              spokeAtLeastOnce = true;\n            }\n            requestAnimationFrame(detectSound);\n          };\n          detectSound();\n\n          setTimeout(() => {\n            if (!spokeAtLeastOnce) {\n              mediaRecorder.stop();\n              stream.getTracks().forEach((track) => track.stop());\n            } else {\n              setTimer(\n                setInterval(() => {\n                  if (!isSpeaking) {\n                    mediaRecorder.stop();\n                    stream.getTracks().forEach((track) => track.stop());\n                  } else {\n                    isSpeaking = false;\n                  }\n                }, silence_timeout)\n              );\n            }\n          }, initial_silence_timeout);\n        })\n        .catch((err) => {\n          setError(err.message);\n        });\n    },\n    [timer, isRecording, config, sendAudioChunk, endAudioStream]\n  );\n\n  return {\n    startRecording,\n    stopRecording,\n    cancelRecording,\n    isRecording,\n    isSpeaking,\n    isRecordingFinished,\n    error\n  };\n};\n\nexport { useAudio };\n","import { useEffect } from 'react';\nimport { useRecoilState } from 'recoil';\n\nimport { useApi, useAuth } from './api';\nimport { configState } from './state';\nimport { IChainlitConfig } from './types';\n\nconst useConfig = (accessToken?: string) => {\n  const [config, setConfig] = useRecoilState(configState);\n  const { isAuthenticated } = useAuth();\n  const language = navigator.language || 'en-US';\n\n  const { data, error, isLoading } = useApi<IChainlitConfig>(\n    !config && isAuthenticated\n      ? `/project/settings?language=${language}`\n      : null,\n    { token: accessToken }\n  );\n\n  useEffect(() => {\n    if (!data) return;\n    setConfig(data);\n  }, [data, setConfig]);\n\n  return { config, error, isLoading, language };\n};\n\nexport { useConfig };\n","export * from './useChatData';\nexport * from './useChatInteract';\nexport * from './useChatMessages';\nexport * from './useChatSession';\nexport * from './useAudio';\nexport * from './useConfig';\nexport * from './api';\nexport * from './types';\nexport * from './context';\nexport * from './state';\nexport * from './utils/message';\n\nexport { Socket } from 'socket.io-client';\n"]}